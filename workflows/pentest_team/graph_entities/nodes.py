from typing import Sequence, Union, Callable, Any, Dict

from langchain_core.messages import ToolMessage, HumanMessage
from langchain_core.tools import BaseTool
from langgraph.prebuilt import ToolInvocation, ToolExecutor

from workflows.pentest_team.graph_entities.statets import SubgraphState, UnifiedState
from workflows.pentest_team.graph_handlers.graph_executor import launch_as_subgraph


def create_tool_node(state, tools: Sequence[Union[BaseTool, Callable]]):
    messages = state.messages

    # Based on the continue condition
    # we know the last message involves a function call
    last_message = messages[-1]
    # We construct an ToolInvocation from the function_call
    tool_calls = last_message.tool_calls
    tool_messages = []
    for tool_call in tool_calls:
        action = ToolInvocation(
            tool=tool_call["name"],
            tool_input=tool_call["args"]
        )
        tool_executor = ToolExecutor(tools)
        # We call the tool_executor and get back a response
        response = tool_executor.invoke(action)
        # We use the response to create a ToolMessage
        tool_message = ToolMessage(
            content=str(response),
            name=action.tool,
            tool_call_id=tool_call["id"]
        )
        tool_messages.append(tool_message)
    # We return a list, because this will get added to the existing list
    return {"messages": tool_messages}


def create_ordinary_node(state: SubgraphState | UnifiedState, agent, name: str):
    """
    Creates a standard node by invoking an agent with the current state and returning the updated state.

    Args:
        state: The current state (PlanningState or UnifiedState), containing messages and sender information.
        agent: The agent to invoke using the messages from the state.
        name: The name of the node or agent invoking the operation.

    Returns:
        A dictionary containing the updated messages and sender after invoking the agent.
    """
    # Invoke the agent with the current state
    response = agent.invoke(state.messages)

    # Return the updated state, which includes the new message and sender's name
    return {
        "messages": [response],  # Add the new message to the list of messages
        "sender": name  # Set the sender to the current agent's name
    }


def node_connector_to_other_team(state, compiled_graph, node_name: str, thread_id: int):
    """
    Connects the current team lead node to another team's graph and forwards the message.

    Args:
        state: The current state, containing messages and sender information.
        compiled_graph: The compiled graph of the other team (e.g., the planning team).
        node_name: The name of the node to which the message should be forwarded.
        thread_id: The thread identifier used for the execution configuration.

    Returns:
        A dictionary representing the updated state with the response from the node of the other team.
    """
    # Prepare input from the team lead to be forwarded to the other team (e.g., planning team)
    input_from_team_lead: Dict[str, Any] = {
        "messages": [
            HumanMessage(content=state.messages[-1].content)  # Forward the last message content
        ],
        'sender': state.sender  # Retain the original sender information
    }

    # Launch the subgraph of the other team (e.g., planning team) using the forwarded message
    state_executed_graph = launch_as_subgraph(
        compiled_graph=compiled_graph,
        inputs=input_from_team_lead,
        thread_id=thread_id
    )

    # Get the content from the last message of the executed graph
    content = state_executed_graph['messages'][-1].content

    # Remove "FINAL ANSWER" from the content if it exists
    cleaned_content = content.replace("FINAL ANSWER", "").strip()

    # Return the updated state with the cleaned response from the other team
    return {
        "messages": [
            HumanMessage(content=cleaned_content)  # Set the cleaned content without "FINAL ANSWER"
        ],
        'sender': node_name,  # Set the sender to the specified node name
    }


