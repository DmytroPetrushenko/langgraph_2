import functools
from typing import Optional, List, Any, Dict
from langgraph.constants import START, END
from langgraph.graph import StateGraph

import forge
from tools.msf_tools import msf_console_scan_tool_dynamic, get_msf_module_options, get_msf_sub_groups_list, \
    get_msf_exact_sub_group_modules_list
from utils import orm_util as orm
from workflows.pentest_team.graph_entities.agents import host_agent_without_tools
from workflows.pentest_team.graph_entities.nodes import create_ordinary_node, node_connector_to_other_team
from workflows.pentest_team.graph_entities.statets import UnifiedState
from workflows.pentest_team.graph_handlers.graph_executor import launch_graph_as_host
from workflows.pentest_team.graph_planning import create_graph_planning_team
from workflows.pentest_team.graph_testing import create_graph_testing_team

TEAM_LEAD_TEAM = 'team_lead_team'
PLANNING_TEAM = 'operation planner'
TESTING_TEAM = 'attack coordinator'
THREAD_PLANNING_TEAM = 2
THREAD_TESTING_TEAM = 3

TEAMS = [PLANNING_TEAM, TESTING_TEAM]  # Team name used in routing logic



def router_team_lead(state: UnifiedState):
    """
    Router function for the team lead node, deciding the next step based on the message content.

    Args:
        state: The current state (UnifiedState), containing messages from the agent.

    Returns:
        A string representing the next node to transition to:
        - 'planning_node' if the message is related to the planning team.
        - '__end__' if the message contains 'FINAL ANSWER'.
        - 'continue' if no specific condition is met, indicating the workflow should continue.
    """
    last_message = state.messages[-1]  # Get the last message from the state

    # Check if the message contains a reference to the 'planning team'
    if isinstance(last_message.content, str) and PLANNING_TEAM in last_message.content.lower():
        return PLANNING_TEAM

    # Check if the message contains a reference to the 'testing team'
    if isinstance(last_message.content, str) and TESTING_TEAM in last_message.content.lower():
        return TESTING_TEAM

    # Check if the 'FINAL ANSWER' is present, indicating the workflow is complete
    elif 'FINAL ANSWER' in last_message.content:
        return '__end__'

    # If no specific conditions are met, continue in the current node
    return "continue"


def create_team_lead_graph(
        model_llm_dict: Dict[str, Any],
        system_messages: Dict[str, str],
        teams_tools: Dict[str, List[str]]
):
    """
    Create a team lead graph with graph entities for the host team, planning team, and testing team.

    Args:
        model_llm_dict (Dict[str, Any]): A dictionary containing LLM models used for creating agents.
        system_messages (Dict[str, str]): A dictionary of system messages for different teams.
        teams_tools (Dict[str, List[str]]): A dictionary mapping team names to their respective tools.

    Returns:
        StateGraph: A configured StateGraph representing the team lead's workflow.
    """
    # Get LLM models
    claude = model_llm_dict['claude']
    gpt = model_llm_dict['gpt']

    # Get system messages for the teams
    team_lead_system_message = system_messages[TEAM_LEAD_TEAM]
    planning_system_message = system_messages[PLANNING_TEAM]
    testing_system_message = system_messages[TESTING_TEAM]

    # Get tools lists for the teams
    planning_tools = teams_tools[PLANNING_TEAM]
    testing_tools = teams_tools[TESTING_TEAM]

    # Creating the team lead node
    system_message = orm.create_message_from_file(team_lead_system_message)
    agent_team_lead = host_agent_without_tools(
        model_llm=claude,
        system_message=system_message,
        teams=TEAMS
    )
    node_team_lead = functools.partial(
        create_ordinary_node,
        agent=agent_team_lead,
        name=TEAM_LEAD_TEAM
    )

    # Creating the planning team node
    compiled_graph_planning_team = create_graph_planning_team(
        model_llm=claude,
        system_message_path=planning_system_message,
        tools=planning_tools
    ).compile()

    node_planning_team = functools.partial(
        node_connector_to_other_team,
        compiled_graph=compiled_graph_planning_team,
        node_name=PLANNING_TEAM,
        thread_id=THREAD_PLANNING_TEAM
    )

    # Creating the testing team node
    compiled_graph_testing_team = create_graph_testing_team(
        model_llm=gpt,
        system_message_path=testing_system_message,
        tools=testing_tools
    ).compile()

    node_testing_team = functools.partial(
        node_connector_to_other_team,
        compiled_graph=compiled_graph_testing_team,
        node_name=TESTING_TEAM,
        thread_id=THREAD_TESTING_TEAM
    )

    # Initialize the state graph with UnifiedState
    workflow = StateGraph(UnifiedState)

    # Adding graph_entities to the workflow graph
    workflow.add_node(TEAM_LEAD_TEAM, node_team_lead)
    workflow.add_node(PLANNING_TEAM, node_planning_team)
    workflow.add_node(TESTING_TEAM, node_testing_team)

    # Defining transitions between graph_entities
    workflow.add_edge(START, TEAM_LEAD_TEAM)
    workflow.add_edge(PLANNING_TEAM, TEAM_LEAD_TEAM)
    workflow.add_edge(TESTING_TEAM, TEAM_LEAD_TEAM)

    # Setting up conditional transitions based on routing logic
    workflow.add_conditional_edges(
        TEAM_LEAD_TEAM,
        router_team_lead,
        {
            PLANNING_TEAM: PLANNING_TEAM,
            TESTING_TEAM: TESTING_TEAM,
            '__end__': END,  # Transition to the end of the workflow
            "continue": TEAM_LEAD_TEAM  # Return to the team lead node
        }
    )

    # Return the configured workflow
    return workflow
