import functools
from typing import Literal, Optional, List, Any
from langgraph.constants import START, END
from langgraph.graph import StateGraph

from utils import orm_util as orm
from tools.msf_tools import get_msf_sub_groups_list, get_msf_exact_sub_group_modules_list
from workflows.graph_entities.agents import assistant_agent_with_tools
from workflows.graph_entities.nodes import create_ordinary_node, create_tool_node, create_quasi_human_node
from workflows.graph_entities.statets import TeamState

# Define constants for the Operation Planner node
PLANNING_NODE_NAME = "Operation Planner"  # Name of the main node for operation planning
QAUSI_HUMAN_NODE = "Qauzi Human"
PLANNING_SYSTEM_MESSAGE = 'strategy#2.txt'  # File containing the system message for the Operation Planner
TOOL_NODE_NAME = "call_tool"  # Name of the node responsible for handling tool execution
PLANNING_TOOLS = [get_msf_sub_groups_list,
                  get_msf_exact_sub_group_modules_list]  # List of tools used by the Operation Planner

HUMAN_QUESTION = (
    "If you have completed all the necessary sQUASI_HUMAN_NODEteps for the current task, output the result and add "
    "\"FINAL ANSWER\" at the end."
)


def create_graph_planning_team(
        model_llm,
        system_message_path: Optional[str] = None,
        tools: Optional[List[Any]] = None
):
    """
    Create a planning graph for the Operation Planner agent with tool usage.

    Args:
        model_llm: The Large Language Model (LLM) used for creating agents that interact
                   with the planning workflow.
        system_message_path (Optional[str]): Path to a custom system message file. If None, uses the default message.
        tools (Optional[List[Any]]): A list of tools to be used by the Operation Planner agent.
                                     If None, a default set of tools will be used.

    Returns:
        StateGraph: A configured StateGraph representing the planning workflow for the Operation Planner.
    """
    # Define the tools to be used by the Operation Planner agent
    tools = PLANNING_TOOLS if tools is None else tools

    # Load a system message to guide the Operation Planner agent
    system_message_path = PLANNING_SYSTEM_MESSAGE if system_message_path is None else system_message_path
    system_message = orm.create_message_from_file(system_message_path)

    # Create the Operation Planner agent using the provided tools and system message
    operation_planner_agent = assistant_agent_with_tools(
        model_llm=model_llm,
        tools=tools,
        system_message=system_message
    )

    # Define the Operation Planner node that will handle the planning logic
    operation_planner_node = functools.partial(
        create_ordinary_node,
        agent=operation_planner_agent,
        name=PLANNING_NODE_NAME
    )

    # Define the tool node responsible for executing tools within the graph
    tool_node = functools.partial(
        create_tool_node,
        tools=tools
    )

    # Define the Quasi Human node
    quasi_human_node = functools.partial(
        create_quasi_human_node,
        name=QAUSI_HUMAN_NODE
    )

    # Initialize the state graph with SubgraphState
    workflow = StateGraph(TeamState)

    # Add nodes to the graph
    workflow.add_node(PLANNING_NODE_NAME, operation_planner_node)  # Main node for planning strategy
    workflow.add_node(TOOL_NODE_NAME, tool_node)  # Node for executing tools
    workflow.add_node(QAUSI_HUMAN_NODE, quasi_human_node)

    # Define the edges (transitions) between nodes
    workflow.add_edge(START, PLANNING_NODE_NAME)  # Start the workflow at the Operation Planner node
    workflow.add_edge(TOOL_NODE_NAME, PLANNING_NODE_NAME)  # After tool execution, return to the planner node
    workflow.add_edge(QAUSI_HUMAN_NODE, PLANNING_NODE_NAME)

    # Add conditional transitions based on decisions from the router
    workflow.add_conditional_edges(
        PLANNING_NODE_NAME,
        router,  # Router determines the next action based on the current state
        {
            "call_tool": TOOL_NODE_NAME,  # If a tool is required, move to the tool node
            "__end__": END,  # If the workflow is complete, end the process
            "continue": QAUSI_HUMAN_NODE  # If continuing, loop back to the planner node
        }
    )

    # Return the configured workflow graph
    return workflow


def router(state: TeamState) -> Literal["call_tool", "__end__", "continue"]:
    """
    The router function decides the next action based on the state.

    Args:
        state: The current PlanningState, which contains messages and tool calls.

    Returns:
        One of three outcomes:
        - "call_tool": If the last message triggered a tool call.
        - "__end__": If the last message contains "FINAL ANSWER", indicating the process is complete.
        - "continue": If the process should continue without tool execution.
    """
    last_message = state.messages[-1]

    if last_message.tool_calls:
        # The previous agent is invoking a tool
        return "call_tool"

    if "FINAL ANSWER" in last_message.content:
        # Any agent decided the work is done
        return "__end__"

    return "continue"
