import functools
import re
from typing import List, Any, Dict
from langgraph.constants import START, END
from langgraph.graph import StateGraph

from constants import PLANNER_NODE, TESTING_NODE
from utils import orm_util as orm
from workflows.graph_entities.agents import assistant_agent_without_tools
from workflows.graph_entities.nodes import create_ordinary_node, node_connector_to_other_team
from workflows.graph_entities.statets import TeamState
from workflows.team_pentest.graph_planning_1 import create_graph_planning_team
from workflows.team_pentest.graph_testing import create_graph_testing_team

TEAM_LEAD_TEAM = 'team_lead_team'
THREAD_PLANNER_NODE_NAME = 2
THREAD_TESTING_TEAM = 3

TEAMS = [PLANNER_NODE, TESTING_NODE]  # Team name used in routing logic
PATTERN_PLANNER = re.compile(PLANNER_NODE)
PATTERN_TESTING = re.compile(TESTING_NODE)

def create_team_lead_graph(
        model_llm_dict: Dict[str, Any],
        system_messages: Dict[str, Any],
        teams_tools: Dict[str, List[str]]
):
    """
    Create a team lead graph with graph entities for the host team, planning team, and testing team.

    Args:
        model_llm_dict (Dict[str, Any]): A dictionary containing LLM models used for creating agents.
        system_messages (Dict[str, str]): A dictionary of system messages for different teams.
        teams_tools (Dict[str, List[str]]): A dictionary mapping team names to their respective tools.

    Returns:
        StateGraph: A configured StateGraph representing the team lead's workflow.
    """
    # Get LLM models
    claude = model_llm_dict['claude']
    gpt = model_llm_dict['gpt']

    # Get system messages for the teams
    team_lead_system_message = system_messages[TEAM_LEAD_TEAM]
    planning_system_message = system_messages[PLANNER_NODE]
    testing_system_message = system_messages[TESTING_NODE]

    # Get tools lists for the teams
    planning_tools = teams_tools[PLANNER_NODE]
    testing_tools = teams_tools[TESTING_NODE]

    # Creating the team lead node
    system_message = orm.create_message_from_file(team_lead_system_message)
    agent_team_lead = assistant_agent_without_tools(
        model_llm=claude,
        system_message=system_message,
        teams=TEAMS
    )
    node_team_lead = functools.partial(
        create_ordinary_node,
        agent=agent_team_lead,
        name=TEAM_LEAD_TEAM
    )

    # Creating the planning team node
    compiled_graph_planning_team = create_graph_planning_team(
        model_llm=gpt,
        all_sys_messages_paths=planning_system_message,
        tools=planning_tools
    ).compile()

    node_planning_team = functools.partial(
        node_connector_to_other_team,
        compiled_graph=compiled_graph_planning_team,
        node_name=PLANNER_NODE,
        thread_id=THREAD_PLANNER_NODE_NAME
    )

    # Creating the testing team node
    compiled_graph_testing_team = create_graph_testing_team(
        model_llm=gpt,
        system_message_path=testing_system_message,
        tools=testing_tools
    ).compile()

    node_testing_team = functools.partial(
        node_connector_to_other_team,
        compiled_graph=compiled_graph_testing_team,
        node_name=TESTING_NODE,
        thread_id=THREAD_TESTING_TEAM
    )

    # Initialize the state graph with UnifiedState
    workflow = StateGraph(TeamState)

    # Adding graph_entities to the workflow graph
    workflow.add_node(TEAM_LEAD_TEAM, node_team_lead)
    workflow.add_node(PLANNER_NODE, node_planning_team)
    workflow.add_node(TESTING_NODE, node_testing_team)

    # Defining transitions between graph_entities
    workflow.add_edge(START, TEAM_LEAD_TEAM)
    workflow.add_edge(PLANNER_NODE, TEAM_LEAD_TEAM)
    workflow.add_edge(TESTING_NODE, TEAM_LEAD_TEAM)

    # Setting up conditional transitions based on routing logic
    workflow.add_conditional_edges(
        TEAM_LEAD_TEAM,
        router_team_lead,
        {
            PLANNER_NODE: PLANNER_NODE,
            TESTING_NODE: TESTING_NODE,
            '__end__': END,  # Transition to the end of the workflow
            "continue": TEAM_LEAD_TEAM  # Return to the team lead node
        }
    )

    # Return the configured workflow
    return workflow



def router_team_lead(state: TeamState):
    """
    Router function for the team lead node, deciding the next step based on the message content.

    Args:
        state: The current state (UnifiedState), containing messages from the agent.

    Returns:
        A string representing the next node to transition to:
        - 'planning_node' if the message is related to the planning team.
        - '__end__' if the message contains 'FINAL ANSWER'.
        - 'continue' if no specific condition is met, indicating the workflow should continue.
    """
    last_message = state.messages[-1]  # Get the last message from the state

    # Check if the message contains a reference to the 'planning team'
    if isinstance(last_message.content, str) and re.search(PLANNER_NODE, last_message.content):
        return PLANNER_NODE

    # Check if the message contains a reference to the 'testing team'
    if isinstance(last_message.content, str) and re.search(TESTING_NODE, last_message.content):
        return TESTING_NODE

    # Check if the 'FINAL ANSWER' is present, indicating the workflow is complete
    elif 'FINAL ANSWER' in last_message.content:
        return '__end__'

    # If no specific conditions are met, continue in the current node
    return "continue"
