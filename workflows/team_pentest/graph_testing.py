import functools
from typing import Literal, Optional, List, Any

from langgraph.constants import START, END
from langgraph.graph import StateGraph
from langgraph.prebuilt import ToolNode

from utils import orm_util as orm
from tools.msf_tools import get_msf_module_options, msf_console_scan_tool_dynamic
from workflows.graph_entities.agents import assistant_agent_with_tools
from workflows.graph_entities.nodes import create_ordinary_node, create_tool_node
from workflows.graph_entities.statets import TeamState

# Define constants for the Attack Coordinator node
TESTING_NODE_NAME = "Attack Coordinator"
TESTING_SYSTEM_MESSAGE = 'pentest_msf#1.txt'  # File containing the system message for the Attack Coordinator
TOOL_NODE_NAME = "call_tool"  # Name of the node responsible for handling tool execution
TESTING_TOOLS = [msf_console_scan_tool_dynamic, get_msf_module_options]  # List of tools used by the Attack Coordinator


def create_graph_testing_team(
    model_llm,
    system_message_path: Optional[str] = None,
    tools: Optional[List[Any]] = None
) -> StateGraph:
    """
    Create and configure the testing graph for the Attack Coordinator node.

    This function sets up a StateGraph that represents the workflow for security testing,
    including an Attack Coordinator node and a Tool Node for executing various testing tools.

    Args:
        model_llm: The language model instance for the Attack Coordinator agent.
        system_message_path (Optional[str]): Path to a custom system message file.
                                             If None, uses the default message.
        tools (Optional[List[Any]]): A list of tools to be used by the Attack Coordinator agent.
                                     If None, a default set of tools will be used.

    Returns:
        StateGraph: A configured StateGraph representing the testing workflow.
    """

    # Define the tools to be used by the Attack Coordinator agent
    tools = TESTING_TOOLS if tools is None else tools

    # Load the system message from the provided file or use the default one
    system_message_path = TESTING_SYSTEM_MESSAGE if system_message_path is None else system_message_path
    system_message = orm.create_message_from_file(system_message_path)

    # Create the Attack Coordinator agent with the specified tools and system message
    attack_coordinator_agent = assistant_agent_with_tools(
        model_llm=model_llm,
        tools=tools,
        system_message=system_message
    )

    # Define the Attack Coordinator node using a standard node creation method
    node_attack_coordinator = functools.partial(
        create_ordinary_node,
        agent=attack_coordinator_agent,
        name=TESTING_NODE_NAME
    )

    # Define the Tool Node which handles the execution of the testing tools
    node_tools = functools.partial(
        create_tool_node,
        tools=tools
    )

    # Initialize the state graph with SubgraphState as the base state
    graph = StateGraph(TeamState)

    # Add nodes to the graph: Attack Coordinator and Tool Node
    graph.add_node(TESTING_NODE_NAME, node_attack_coordinator)
    graph.add_node(TOOL_NODE_NAME, node_tools)

    # Define transitions: Starting from 'START' to the Attack Coordinator node
    graph.add_edge(START, TESTING_NODE_NAME)

    # Add conditional transitions from the Attack Coordinator node:
    # - 'call_tool' leads to the Tool Node
    # - '__end__' leads to the end of the graph
    # - 'continue' loops back to the Attack Coordinator for further actions
    graph.add_conditional_edges(
        TESTING_NODE_NAME,
        router,
        {
            'call_tool': TOOL_NODE_NAME,
            '__end__': END,
            'continue': TESTING_NODE_NAME
        }
    )

    # Define transition back to the Attack Coordinator node after tool execution
    graph.add_edge(TOOL_NODE_NAME, TESTING_NODE_NAME)

    # Return the fully configured state graph
    return graph


def router(state: TeamState) -> Literal["call_tool", "__end__", "continue"]:
    """
    The router function decides the next action based on the state.

    Args:
        state: The current PlanningState, which contains messages and tool calls.

    Returns:
        One of three outcomes:
        - "call_tool": If the last message triggered a tool call.
        - "__end__": If the last message contains "FINAL ANSWER", indicating the process is complete.
        - "continue": If the process should continue without tool execution.
    """
    last_message = state.messages[-1]

    if last_message.tool_calls:
        # The previous agent is invoking a tool
        return "call_tool"

    if "FINAL ANSWER" in last_message.content:
        # The process is complete, end the workflow
        return "__end__"

    # Continue processing if no specific conditions are met
    return "continue"
